#!/usr/bin/env node
const fs = require('fs');
const path = require('path');

// This script copies the tsc-emitted declaration files from
// dist/out-tsc/packages/<pkg>/src/index.d.ts -> dist/packages/<pkg>/index.d.ts
// It auto-discovers packages by looking for a package's ng-package.json
// and fails the process by default if a source declaration is missing.

const workspacePackagesDir = path.resolve(__dirname, '..', 'packages');
const pkgs = [];
try {
  for (const name of fs.readdirSync(workspacePackagesDir)) {
    const pkgDir = path.join(workspacePackagesDir, name);
    const ngpkg = path.join(pkgDir, 'ng-package.json');
    if (fs.existsSync(ngpkg)) {
      pkgs.push(name);
    }
  }
} catch (err) {
  console.error('Failed to list packages directory', err.message);
  process.exit(2);
}

if (pkgs.length === 0) {
  console.error('No packages found to process. Aborting.');
  process.exit(2);
}

let hadError = false;
const lenient = process.env.COPY_DECLS_LENIENT === '1';

for (const pkg of pkgs) {
  try {
    const outSrc = path.join(
      'dist',
      'out-tsc',
      'packages',
      pkg,
      'src',
      'index.d.ts'
    );
    const finalDir = path.join('dist', 'packages', pkg);
    const final = path.join(finalDir, 'index.d.ts');

    if (!fs.existsSync(outSrc)) {
      const msg = `source d.ts missing for ${pkg}: ${outSrc}`;
      if (lenient) {
        console.warn(msg);
        continue;
      } else {
        console.error(msg);
        hadError = true;
        continue;
      }
    }

    if (!fs.existsSync(finalDir)) {
      const msg = `final package dir missing for ${pkg}: ${finalDir}`;
      if (lenient) {
        console.warn(msg);
        continue;
      } else {
        console.error(msg);
        hadError = true;
        continue;
      }
    }

    let content = fs.readFileSync(outSrc, 'utf8');
    // If the index.d.ts is a simple re-export (export * from './lib/...'),
    // try to inline the referenced lib .d.ts files so the final package
    // index.d.ts contains actual declarations and JSDoc for editors.
    const reExportRegex = /export \* from '(\.\/lib\/[\w\-/]+)';?/g;
    const matches = [...content.matchAll(reExportRegex)];
    if (matches.length > 0) {
      let inlined = '';
      for (const m of matches) {
        const rel = m[1]; // e.g. ./lib/async
        // build candidate path inside dist/out-tsc
        const candidate = path.join(
          'dist',
          'out-tsc',
          'packages',
          pkg,
          rel.replace('./', '') + '.d.ts'
        );
        if (fs.existsSync(candidate)) {
          inlined += '\n/* Inlined from ' + candidate + ' */\n';
          inlined += fs.readFileSync(candidate, 'utf8');
        } else {
          // if candidate not found, leave the original export line
          inlined += '\n' + m[0] + '\n';
        }
      }
      // if we found inlined content, replace content with it
      if (inlined.trim()) {
        content = inlined;
      }
    }

    // Add a small header to indicate this file was copied from tsc output.
    const header = `/* Automatically copied from ${outSrc} - generated by tsc (preserves JSDoc) */\n`;
    fs.writeFileSync(final, header + content, 'utf8');
    console.log('Copied declarations for', pkg);
  } catch (e) {
    console.error(
      'Failed to copy declarations for',
      pkg,
      e && e.message ? e.message : e
    );
    hadError = true;
  }
}

console.log('Declaration copy complete');
if (hadError) {
  console.error('\nOne or more declaration copy steps failed.');
  console.error(
    'Set environment variable COPY_DECLS_LENIENT=1 to skip missing packages in CI.'
  );
  process.exit(1);
}
